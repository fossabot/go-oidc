name: Certification
on:
    push:
      branches: [main]
    pull_request:
      branches: [main]
    workflow_dispatch:  # Allow manual triggering of this workflow

jobs:

  run-tests:
    runs-on: ubuntu-latest
    env:
      CS_VERSION: "v5.1.22"

    strategy:
      fail-fast: false
      matrix:
        # A plan has as required params the name, the config and the path to the
        # go routine that spins up the auth server.
        # If modules is not informed, all the plan's test modules will execute.
        # The variants such as response_type and client_auth_type are required
        # depending on the test plan.
        plan:
          - name: oidcc-dynamic-certification-test-plan
            modules:
              - oidcc-discovery-endpoint-verification
              - oidcc-server
              - oidcc-idtoken-rs256
              - oidcc-userinfo-rs256
              - oidcc-redirect-uri-query-OK
              - oidcc-registration-jwks-uri
              - oidcc-refresh-token
            config: ./examples/oidc/cs_config.json
            server_main: ./examples/oidc/main.go
            response_type: code id_token
          - name: oidcc-dynamic-certification-test-plan
            modules:
              - oidcc-server
            config: ./examples/oidc/cs_config.json
            server_main: ./examples/oidc/main.go
            response_type: code
          - name: oidcc-dynamic-certification-test-plan
            modules:
              - oidcc-server
            config: ./examples/oidc/cs_config.json
            server_main: ./examples/oidc/main.go
            response_type: code id_token token
          - name: fapi2-message-signing-id1-test-plan
            modules:
              - fapi2-security-profile-id2-discovery-end-point-verification
              - fapi2-security-profile-id2-happy-flow
              - fapi2-security-profile-id2-ensure-request-object-with-multiple-aud-succeeds
              - fapi2-security-profile-id2-ensure-authorization-request-without-state-success
              - fapi2-security-profile-id2-ensure-authorization-request-without-nonce-success
              - fapi2-security-profile-id2-ensure-other-scope-order-succeeds
              - fapi2-security-profile-id2-test-claims-parameter-identity-claims
              - fapi2-security-profile-id2-access-token-type-header-case-sensitivity
              - fapi2-security-profile-id2-check-dpop-proof-nbf-exp
              - fapi2-security-profile-id2-ensure-dpopproof-with-iat-10seconds-before-succeeds
              - fapi2-security-profile-id2-ensure-response-type-code-idtoken-fails
              - fapi2-security-profile-id2-ensure-client-id-in-token-endpoint
              - fapi2-security-profile-id2-ensure-different-nonce-inside-and-outside-request-object
              - fapi2-security-profile-id2-ensure-holder-of-key-required
              - fapi2-security-profile-id2-ensure-authorization-code-is-bound-to-client
              - fapi2-security-profile-id2-state-only-outside-request-object-not-used
            config: ./examples/oidc/cs_config.json
            server_main: ./examples/fapi2/main.go
            sender_constrain: dpop
            client_auth_type: private_key_jwt
            openid: openid_connect
            fapi_request_method: unsigned
            fapi_profile: plain_fapi
            fapi_response_mode: plain_response

    steps:
        - uses: actions/checkout@v4
        - uses: actions/setup-go@v4
          with:
            go-version: '1.22.x'

        - name: Cache Conformance Suite repository
          uses: actions/cache@v3
          id: cache-cs
          with:
            path: ./conformance-suite
            key: cs-${{ env.CS_VERSION }}

        - name: Set up Conformance Suite
          if: steps.cache-cs.outputs.cache-hit != 'true'
          run: |
            git clone --branch "release-$CS_VERSION" --single-branch --depth=1 https://gitlab.com/openid/conformance-suite.git
            docker compose -f ./conformance-suite/builder-compose.yml run builder

        - name: Run Conformance Suite
          run: |
            docker compose -f cs-docker-compose.yml up -d
            echo "Wait for the conformance to be ready"
            timeout 60 bash -c '
            while [ "$(curl -skf -o /dev/null -w ''%{http_code}'' https://localhost:8443/api/runner/available)" != "200" ]; do
              echo "Conformance suite not ready, sleeping for 2 seconds"
              sleep 2
            done
            echo "Conformance suite is ready"
            ' || echo "Timeout reached before the conformance suite is ready"

        - name: Start authorization server
          run: |
            # Run the server on background and save the process ID so we can kill it later
            go run ${{ matrix.plan.server_main }} & echo $! > /tmp/go-server.pid

        - name: Run test plan
          run: |
            # Prepare base arguments
            ARGS="--plan=${{ matrix.plan.name }} --config=${{ matrix.plan.config }}"

            # Specified modules are the only ones to execute.
            if [ -n "${{ matrix.plan.modules }}" ]; then
              # Convert the test modules list to comma-separated string
              MODULES=$(echo '${{ toJson(matrix.plan.modules) }}' | jq -r '.[]' | tr '\n' ',' | sed 's/,$//')
              ARGS="$ARGS --modules=$MODULES"
            fi

            # Excluded modules won't execute.
            if [ -n "${{ matrix.plan.excluded_modules }}" ]; then
              # Convert the excluded test modules list to comma-separated string
              MODULES=$(echo '${{ toJson(matrix.plan.excluded_modules) }}' | jq -r '.[]' | tr '\n' ',' | sed 's/,$//')
              ARGS="$ARGS --exclude-modules=$MODULES"
            fi

            # Add variants
            if [ -n "${{ matrix.plan.response_type }}" ]; then
              ARGS="$ARGS --response_type=\"${{ matrix.plan.response_type }}\""
            fi

            echo "Running with arguments: $ARGS"
            # Ensure that the arguments are passed correctly with spaces preserved.
            sh -c "go run cmd/testrunner/main.go $ARGS"

            # Find the generated test log
            ZIP_FILE=$(find . -maxdepth 1 -name "*.zip" -print -quit)
            # Extract the file name from the path
            FILE_NAME=$(basename "$ZIP_FILE")
            # Set the file name in an env var for the upload job
            echo "FILE_NAME=$FILE_NAME" >> $GITHUB_ENV

        - name: Upload test plan Log
          uses: actions/upload-artifact@v4
          if: ${{ always() }}
          with:
            path: ${{ env.FILE_NAME }}
            name: ${{ strategy.job-index }}-${{ env.FILE_NAME }}

        - name: Cleanup
          if: always()
          run: |
            docker compose -f cs-docker-compose.yml down
            kill $(cat /tmp/go-server.pid)

  all-tests-succeeded:
    runs-on: ubuntu-latest
    needs: run-tests
    if: success()
    steps:
      - name: Test plans passed
        run: echo "All test plans passed successfully!"
